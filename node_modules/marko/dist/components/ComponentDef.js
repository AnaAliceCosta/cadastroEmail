"use strict";

var componentUtil = require("./util");
var attachBubblingEvent = componentUtil.Z_;
var addDelegatedEventHandler = require("./event-delegation").___;
var extend = require("raptor-util/extend");
var KeySequence = require("./KeySequence");

var FLAG_WILL_RERENDER_IN_BROWSER = 1;
// var FLAG_HAS_BODY_EL = 2;
// var FLAG_HAS_HEAD_EL = 4;
var FLAG_OLD_HYDRATE_NO_CREATE = 8;

/**
 * A ComponentDef is used to hold the metadata collected at runtime for
 * a single component and this information is used to instantiate the component
 * later (after the rendered HTML has been added to the DOM)
 */
function ComponentDef(component, componentId, globalComponentsContext) {
    this._a_ = globalComponentsContext; // The AsyncWriter that this component is associated with
    this._b_ = component;
    this.id = componentId;

    this._c_ = undefined; // An array of DOM events that need to be added (in sets of three)

    this._d_ = false;

    this._e_ = false;
    this._f_ = 0;

    this._g_ = 0; // The unique integer to use for the next scoped ID

    this.w_ = null;

    this._h_ = null;
}

ComponentDef.prototype = {
    _i_: function (key) {
        var keySequence = this.w_ || (this.w_ = new KeySequence());
        return keySequence._i_(key);
    },

    _j_: function (key, bodyOnly) {
        var lookup = this._h_ || (this._h_ = {});
        lookup[key] = bodyOnly ? 2 : 1;
    },

    /**
     * This helper method generates a unique and fully qualified DOM element ID
     * that is unique within the scope of the current component. This method prefixes
     * the the nestedId with the ID of the current component. If nestedId ends
     * with `[]` then it is treated as a repeated ID and we will generate
     * an ID with the current index for the current nestedId.
     * (e.g. "myParentId-foo[0]", "myParentId-foo[1]", etc.)
     */
    elId: function (nestedId) {
        var id = this.id;
        if (nestedId == null) {
            return id;
        } else {
            if (nestedId.indexOf("#") === 0) {
                id = "#" + id;
                nestedId = nestedId.substring(1);
            }

            return id + "-" + nestedId;
        }
    },
    /**
     * Returns the next auto generated unique ID for a nested DOM element or nested DOM component
     */
    _k_: function () {
        return this.id + "-c" + this._g_++;
    },

    d: function (eventName, handlerMethodName, isOnce, extraArgs) {
        addDelegatedEventHandler(eventName);
        return attachBubblingEvent(this, handlerMethodName, isOnce, extraArgs);
    },

    get _l_() {
        return this._b_._l_;
    }
};

ComponentDef._m_ = function (o, types, global, registry) {
    var id = o[0];
    var typeName = types[o[1]];
    var input = o[2];
    var extra = o[3];

    var isLegacy = extra.l;
    var state = extra.s;
    var componentProps = extra.w;
    var flags = extra.f;

    var component = typeName /* legacy */ && registry._n_(typeName, id, isLegacy);

    // Prevent newly created component from being queued for update since we area
    // just building it from the server info
    component.r_ = true;

    if (!isLegacy && flags & FLAG_WILL_RERENDER_IN_BROWSER && !(flags & FLAG_OLD_HYDRATE_NO_CREATE)) {
        if (component.onCreate) {
            component.onCreate(input, { global: global });
        }
        if (component.onInput) {
            input = component.onInput(input, { global: global }) || input;
        }
    } else {
        if (state) {
            var undefinedPropNames = extra.u;
            if (undefinedPropNames) {
                undefinedPropNames.forEach(function (undefinedPropName) {
                    state[undefinedPropName] = undefined;
                });
            }
            // We go through the setter here so that we convert the state object
            // to an instance of `State`
            component.state = state;
        }

        if (componentProps) {
            extend(component, componentProps);
        }
    }

    component.n_ = input;

    if (extra.b) {
        component.k_ = extra.b;
    }

    var scope = extra.p;
    var customEvents = extra.e;
    if (customEvents) {
        component.W_(customEvents, scope);
    }

    component.p_ = global;

    return {
        id: id,
        _b_: component,
        _o_: extra.r,
        _c_: extra.d,
        _f_: extra.f || 0
    };
};

module.exports = ComponentDef;